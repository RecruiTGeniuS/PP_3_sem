# Вопросы к защите. Лаба 1.
---
## Содержание
1. [Дайте определение терминам класс и объект.](#1-определение-терминам-класс-и-объект)
2. [Опишите принципы ООП.](#2-принципы-ооп)
3. [Приведите реализацию принципов ООП в Python.](#3-реализация-принципов-ооп-в-python)
4. [Дайте определение диаграммы классов.](#4-определение-диаграммы-классов)
5. [Перечислите и дайте определение видам связи в диаграмме классов.](#5-все-виды-связи-в-диаграмме-классов)
6. [Перечислите стратегии обработки исключительных ситуаций.](#6-стратегии-обработки-исключительных-ситуаций)
7. [Приведите реализацию обработки собственного типа ошибки в Python.](#7-реализация-обработки-собственного-типа-ошибки-в-pyhon)
8. [Классифицируйте языки программирования.](#8-классификация-языков-программирования)
9. [Опишите структуру XML.](#9-структура-xml)
10. [Опишите структуру JSON.](#10-структура-json)

---
### 1. __Определение терминам класс и объект__

***Класс*** - модель(или шаблон) для создания объектов определённого типа, описывающая их структуру (набор полей и их начальное состояние) и определяющий методы для работы с этими объектами.  
[по умному с Википедии]

***Объект*** - это экземпляр класса, созданный на его основе.  
[тоже типа по умному, но уже без Википедии]


>Теперь если простым языком: *класс* - это описание того, какими свойствами и поведением будет обладать объект. А *объект* - это экземпляр с собственным состоянием этих свойств.

Примеры класса и объекта на Python:
```Python
# Сам класс
class Person():
    # Конструктор, обозначается __init__
    def __inti__(self, name): # self - это ссылка на текущий объект, типа this на С++
        self.name = name 
        self.age = 20
        # Переменные в классе называются атрибутами(иногда полями), поэтому name и age - атрибуты(или поля)

    # Метод класса
    def sayHello(self):
        print("Hello!")
    

jack = Person("Jack") # Объект jack, класса Person
jack.sayHello() # Вызов метода

```

### 2. **Принципы ООП**
---
>***Инкапсуляция*** - механизм языка, позволяющий объеденить данные и методы, работающие с этими данными в единый объект, и скрыть детали реализации от пользователя.

За сокрытие отвечают модификаторы доступа (public, protected, private). В питоне их кстати нет, там есть просто соглашение PEP8 (это не правило языка и его можно нарушить), согласно которому:  
* Если поле(атрибут) или метод имею **два занака подчёркивания** впереди (`self.__name`) то это private
* Если один знак подчёркивания (`_age`) то protected

>***Наследование*** - механизм языка, позволяющий описывать новый класс на основе существующего.

Опять же это что-то типа надстройки. То есть у нас есть дом(класс) и наследуемый дом(класс) берёт за основу тот же дом в его виде и делает какую-то надстройку над ним.   

>***Полиморфизм*** - возможность единым образом работать с разными типами данных.   

 К примеру можно взять классы `Круг` и `Квадрат`, которые наследуются от абрстрактного класса `Фигура` и в которых будет метод `нарисовать`. Метод для для всех классов один - это `нарисовать` и суть одна - нарисовать эту фигуру, но агрументы, которые будут передаваться в метод разные, для круга мы будем передавать радиус, а для квадрата длину сторону. То есть у нас один метод в разных классах, с одной сутью, но с разной реализацией - это как раз и есть полиморфизм.

>***Абстракция*** - это процесс выделения общих характеристик и функциональности объектов или системы, игнорируя детали реализации.

Вообще абстрацию редко выделяют в отдельный принцип, поэтому на защите можно скзаать только те 3, которые выше.

Все принципы взаимосвязаны между собой и один не существует без другого.

### 3. Реализация принципов ООП в Python
---
Возьмём для примера иерархию классов, где абстрактным классом будет `Фигура` и будет два производных от неё - `Круг` и `Прямоугольник`.

```Python
# Абстрактный класс фигуры
class Shape():
    def __init__(self):
        pass

    def square():
        pass

# Производный класс круг
class Circle(Shape):
    def __init__(self, radius):
        self.__radius = radius

    def square(self):
        print(self.__radius * 3.14)

# Производный класс прямоугольник
class Rectangle(Shape):
    def __init__(self, side_1, side_2):
        self.__side_1 = side_1
        self.__side_2 = side_2

    def square(self):
        print(self.__side_1 * self.__side_2)

# Объекты классов
circle = Circle(2)
rectangle = Rectangle(5,2)

circle.square()     # 6.28
rectangle.square()  # 10
```
Пример абстракции - абстраткный класс `Shape`.

`Circle` и `Rectangle` производные классы от `Shape` - это наследование.

Метод нахождения площади `square()` переопределён в производных классах - это полиморфизм

Инкапсуляция то что внутри классов есть поля и методы, а также то что в `Circle` и `Rectangle` находятся в protected.

### 4. Определение диаграммы классов
---
***Диаграмма классов*** - диаграмма языка моделирования UML, демонстрирующая общую структуру иерархии классов, их взаимодействие, методы, поля и интерфейсы.

### 5. Виды связи в диаграмме классов

Всего их 6:

1. ***Ассоциация*** - используется чтобы показать, что между классами существует некоторая связь.  
![Ассоциация](https://habrastorage.org/getpro/habr/upload_files/1eb/4b7/ff9/1eb4b7ff9ff016677a1cd4ef6644f34f.png)

2. ***Наследование*** - показывает отношение между базовыми и производными классами.  
![Alt text](image-1.png)
3. ***Реализация*** - отношение, в котором один элемент реализует поведение, заданное другим.
![Alt text](image-2.png)

4. ***Зависимость*** - показывает, что изменение одного класса требует изменение другого.  
![](https://habrastorage.org/getpro/habr/upload_files/c6f/98a/bca/c6f98abcaacdf2b7fe3f5b0893eee470.png)
 
5. ***Агрегация*** -  показывает что один класс является частью другого класса.
![](https://habrastorage.org/getpro/habr/upload_files/411/451/9c5/4114519c58370797b48aa03d75153be6.png)
 
6. ***Композиция*** - разновидность агрегации, только тут зависимые классы не могут существовать без класса агрегатора.  
![](https://habrastorage.org/getpro/habr/upload_files/e11/e62/e12/e11e62e12bc6ef530d3263788eb2b08c.png)

### 6. Стратегии обработки исключительных ситуаций
---
Для начала, как говорит интернет *исключительная ситуация* - это непредвиденное исключение из нормального хода выполнения программы, которое происходит в результате ошибок в работе системы.По идее исключение = ошибка, получается можно взять слайд с его лекции про обработку ошибок. Надеюсь я верно понял.

Теперь к стратегиям обработки исключений:  
* *Ничего не делать* - выход из программы. То есть мы ничего не делам, программа выдаёт исключение и завершается.
* *Создать метод, сообщающий о состоянии объекта*. Получается при возниквновении исключительной ситуации метод будет выводить состояние объекта и на основе этого можно будет делать выводы как всё исправить.
* *Создание фабричного метода*. Это такой метод, который может создавать объекты базовом классе и изменять создаваемые объекты в дочерних класса. Это может помочь в ситуациях, когда нам надо добавить новые объекты, при этом у нас не будет ломаться код.
* *Нулевой тип*. Здесь не могу понять что он имел в виду, в инете тоже ничего найти не получилось.
* *Избежать обработки ошибок* тоже самое, что с пунктом выше.
* *Сгенерировать исключение*. При возникновении исключительной ситуации(ошибки) происходит другое действие, написанное нами - то есть исключение. В питоне это, к примеру, `try...except`. 

### 7. Реализация обработки собственного типа ошибки в Python.
---
Здесь будет случай с делением на 0. Если просто поделить число но 0 питоне, то это приведёт к ошибке `ZeroDivisionError`. Чтобы этого не случилось можно использовать конструкцию `try...except`, например так:
```Python
try:
    a = 100
    b = 0
    c = a / b
except ZeroDivisionError as e:
    c = 0
```
Теперь при делении на ноль будет выводить `c = 0`.

### 8. Классификация языков программирования
---
Тут довольно обширная тема, потому что классифицировать ЯП можно по разному. Не знаю какая именно классификая понадобится ему. Тут будет то что было в лекциях, надеюсь прокатит ну и снова надеюсь что я правильно понял.

*  ***Компилируемые и интерпретируемые***
*Компилируемые ЯП* - языки для которых нужен компилятор. До начала выполнения программы через компилятор прогоняется код, написанный на ЯП, переводится в язык, понятный процессору и записывается в файл(например .exe). К таким языкам относится C, C++.  
*Интерпретируемые ЯП* - языки для которых уже нужен не компилятор, а интерпретатор. Интерпретатор проходится по каждной строчке во время выполнения программы и переводит эти строчки в язык, понятный процессору. К таким языком относится Python, JavaScript.  

* ***Высокоуровневые и низкоуровневые***
*Низкоуровневые ЯП* - языки, при помощи которых можно напрямую отдавать команды процессору, они трудны в понимании и написании. Также для каждого процессора этот язык свой, поэтому программы на них не смогут работать на рахны ПК. К этим языкам относятся Машинный код, Assebmler.  
*Высокоуровненые ЯП* - языки, код на которых понятен программисту, на них можно создавать программы, не переживая о совместимости кода с разными процессорами.  

* ***Динамически и статически типизированные***  
*Статическая типизация* - определяет типы данных в программе до её запуска. К примеру в C++, мы постоянно ставим типы данных перед переменными, массивами и тд.
*Динамическая типизация* этого не требует, в ней тип определяется во время запуска программы, к примеру Python, где уже надо писать типы перед переменным и тд, как в плюсах.

* ***Строго и слабо типизированные***
Строгая типизация не позволяет смешивать в выражениях различные типы, например нельзя вычесть из строки множество. Языки со слабой типизацией выполняет множество неявных преобразований автоматически.

### 9. Структура XML
---

***XML***(Xtensible Markup Language) - расширяемый язык разметки. Используется для хранения и передачи данных.

В XML есть теги, текст заключённый в угловые скобки, они показывают системе где начинается и где заканчивается элемент.  
`<tag>` - открывающий тег  
`<\tag>` - закрывающий тег

По структуре:  
XML документ должен содержать корневой элемент. Этот элемент является "родительским" для всех других элементов.
Все элементы формируют иерархическое дерево это дерево начинается с корневого элемента и разветвляется на более низкие уровни элементов.
```XML
<корневой>
    <потомок>
        <подпотомок> ..... </подпотомок>
    </потомок>
</корневой>
```

### 10. Структура JSON
---
***JSON*** (JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript. Но при этом формат независим от JS и может использоваться в любом языке программирования.

Структура JSON состоит из набора пар ключ-значение. В этой паре ключ отделяется от значения при помощи знака двоеточия, а одна пара от другой при помощи запятой. Ключ в JSON должен обязательно быть заключён в двойные кавычки. Также в JSON есть упорядоченный набор значений. Во многих языках это реализованно как массив, вектор, список или последовательность.
```JSON
{
    "name": "Василий",
    "age": 22,
    "mother": {
        "name": "Ольга",
        "age": 51
    },
    "children": [
        "Маша",
        "Игорь",
        "Таня"
    ],
    "married": true,
    "dog": null
}
```
---
### Ссылки
---
* https://ru.hexlet.io/courses/advanced_python/lessons/python_exceptions/theory_unit
* https://habr.com/ru/articles/463125/
* https://habr.com/ru/companies/wunderfund/articles/736526/
* https://habr.com/ru/companies/otus/articles/570882/
* https://itchief.ru/javascript/json#struktura-formata-json
* https://habr.com/ru/articles/554274/
* https://habr.com/ru/articles/161205/
* https://ru.hexlet.io/blog/posts/yazyki-programmirovaniya
* https://habr.com/ru/articles/539784/
* https://habr.com/ru/articles/150041/
* https://habr.com/ru/articles/572234/